/**
 * Innovation Engine
 * Runs eop_innovation_engine skill 24/7 continuously
 * Generates ideas, scores them, and logs to innovations.md
 */

import { getDb } from "./db";
import { innovations } from "../drizzle/schema";
import { desc } from "drizzle-orm";
import { callOpenRouterWithFallback } from "./llmRouter";
import * as fs from "fs/promises";
import * as path from "path";

const INNOVATIONS_FILE = "/home/ubuntu/revvel-skill-runner/innovations.md";

interface Innovation {
  title: string;
  description: string;
  category: "efficiency" | "revenue" | "blue-ocean" | "automation" | "ip-patent" | "cost-optimization" | "business-model";
  impactScore: number;
  effortScore: number;
  noveltyScore: number;
  reasoning: string;
  implementation: string;
  marketPotential: string;
  technicalFeasibility: string;
}

/**
 * Main innovation generation loop
 * Runs continuously 24/7
 */
export async function runInnovationEngine(): Promise<Innovation> {
  const prompt = `You are an innovation engine for a tech entrepreneur. Generate a novel, actionable business idea or product feature.

Focus on:
- AI/ML applications
- Automation and productivity tools
- Revenue-generating features
- Blue Ocean opportunities (uncontested market space)
- Technical feasibility with existing tech stack

Respond with JSON:
{
  "title": "Brief catchy title",
  "description": "2-3 sentence description",
  "category": "efficiency|revenue|blue-ocean|automation|ip-patent|cost-optimization|business-model",
  "impactScore": 0-100 (business impact),
  "effortScore": 0-100 (implementation effort, higher = more effort),
  "noveltyScore": 0-100 (how novel/unique),
  "reasoning": "Why these scores",
  "implementation": "High-level technical approach",
  "marketPotential": "Target market and revenue model",
  "technicalFeasibility": "What tech/APIs needed, complexity level"
}`;

  try {
    const response = await callOpenRouterWithFallback(
      [{ role: "user", content: prompt }],
      "uncensored-only",
      true
    );

    const innovation: Innovation = JSON.parse(response.content);
    
    // Save to database
    await saveInnovation(innovation);
    
    // Append to innovations.md
    await appendToInnovationsFile(innovation);
    
    return innovation;
  } catch (error) {
    console.error("Error generating innovation:", error);
    throw error;
  }
}

/**
 * Save innovation to database
 */
async function saveInnovation(innovation: Innovation): Promise<void> {
  const db = await getDb();
  if (!db) return;

  const innovationId = `INN-${Date.now()}-${Math.random().toString(36).substring(7)}`;
  const priorityScore = (innovation.impactScore * 0.5) + ((100 - innovation.effortScore) * 0.3) + (innovation.noveltyScore * 0.2);
  
  await db.insert(innovations).values({
    innovationId,
    title: innovation.title,
    description: innovation.description,
    category: innovation.category,
    trigger: "eop_innovation_engine",
    impactScore: innovation.impactScore,
    effortScore: innovation.effortScore,
    noveltyScore: innovation.noveltyScore,
    priorityScore,
    status: "proposed",
    contextData: {
      reasoning: innovation.reasoning,
      implementation: innovation.implementation,
      marketPotential: innovation.marketPotential,
      technicalFeasibility: innovation.technicalFeasibility,
    },
  });
}

/**
 * Append innovation to innovations.md file
 */
async function appendToInnovationsFile(innovation: Innovation): Promise<void> {
  const timestamp = new Date().toISOString();
  const entry = `
## ${innovation.title}
**Impact:** ${innovation.impactScore}/100 | **Effort:** ${innovation.effortScore}/100 | **Novelty:** ${innovation.noveltyScore}/100
**Generated:** ${timestamp}  
**Category:** ${innovation.category}

**Description:**  
${innovation.description}

**Reasoning:**  
${innovation.reasoning}

**Implementation:**  
${innovation.implementation}

**Market Potential:**  
${innovation.marketPotential}

**Technical Feasibility:**  
${innovation.technicalFeasibility}

---

`;

  try {
    // Ensure directory exists
    const dir = path.dirname(INNOVATIONS_FILE);
    await fs.mkdir(dir, { recursive: true });
    
    // Check if file exists
    let fileExists = false;
    try {
      await fs.access(INNOVATIONS_FILE);
      fileExists = true;
    } catch {
      // File doesn't exist
    }
    
    // If file doesn't exist, create with header
    if (!fileExists) {
      const header = `# Innovation Log\n\nGenerated by eop_innovation_engine running 24/7\n\n---\n\n`;
      await fs.writeFile(INNOVATIONS_FILE, header);
    }
    
    // Append innovation
    await fs.appendFile(INNOVATIONS_FILE, entry);
  } catch (error) {
    console.error("Error writing to innovations.md:", error);
  }
}

/**
 * Get recent innovations from database
 */
export async function getRecentInnovations(limit: number = 50) {
  const db = await getDb();
  if (!db) return [];

  return await db
    .select()
    .from(innovations)
    .orderBy(desc(innovations.createdAt))
    .limit(limit);
}

/**
 * Get innovations by category
 */
export async function getInnovationsByCategory(category: string) {
  const db = await getDb();
  if (!db) return [];

  const { eq } = await import("drizzle-orm");
  return await db
    .select()
    .from(innovations)
    .where(eq(innovations.category, category as any))
    .orderBy(desc(innovations.createdAt))
    .limit(50);
}

/**
 * Get top-scored innovations
 */
export async function getTopInnovations(limit: number = 20) {
  const db = await getDb();
  if (!db) return [];

  return await db
    .select()
    .from(innovations)
    .orderBy(desc(innovations.priorityScore))
    .limit(limit);
}

/**
 * Read innovations.md file
 */
export async function readInnovationsFile(): Promise<string> {
  try {
    return await fs.readFile(INNOVATIONS_FILE, "utf-8");
  } catch (error) {
    return "# Innovation Log\n\nNo innovations generated yet.\n";
  }
}

/**
 * Start continuous innovation engine
 * Generates an innovation every 30 minutes
 */
export function startContinuousEngine() {
  console.log("[Innovation Engine] Starting 24/7 continuous mode...");
  
  // Generate first innovation immediately
  runInnovationEngine().catch(console.error);
  
  // Then every 30 minutes
  setInterval(() => {
    runInnovationEngine().catch(console.error);
  }, 30 * 60 * 1000);
}
